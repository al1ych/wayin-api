<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <title>svg2map</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

    <style>
        #drop-area {
            border: 2px dashed #ccc;
            border-radius: 20px;
            width: 360px;
            height: 360px;
            font-family: sans-serif;
            right: 16px;
            bottom: 16px;
            position: fixed;
            background-image: url(dd_img.png);
            background-repeat: no-repeat;
            background-position: center;
        }

        #inputfile {
            bottom: 16px;
        }

        #drop-area.highlight {
            border-color: purple;
        }
    </style>

</head>

<div id="drop-area">
    <input type="file" name="inputfile"
           id="inputfile" style="position: fixed; left: 8px;">
</div>
<input name="inputfile"
       id="accuracy_holder" style="position: fixed; right: 0; top: 50px;" value="10" placeholder="accuracy (1-100)">
<input name="inputfile"
       id="grid_accuracy_holder" style="position: fixed; right: 0; top: 75px;" value="30"
       placeholder="grid accuracy (1-40)">
<button
        id="draw_graph_button" style="position: fixed; right: 0; top: 100px;"
        onclick="draw_brief_graph()">Brief connectivity test</button>
<button
        id="draw_connectivity_button" style="position: fixed; right: 0; top: 125px;"
        onclick="draw_full_graph()">Full connectivity test</button>
<button
        id="draw_cada_ruta" style="position: fixed; right: 0; top: 150px;"
        onclick="draw_cada_ruta()">Each route connectivity test</button>
<br>

<script type="text/javascript">
    // drag&drop
    let dropArea = document.getElementById('drop-area');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false)
    });
    function highlight(e) {
        dropArea.classList.add('highlight')
    }
    function unhighlight(e) {
        dropArea.classList.remove('highlight')
    }
    dropArea.addEventListener('drop', handleDrop, false);
    function handleDrop(e) {
        let dt = e.dataTransfer;
        let files = dt.files;
        let f = files[0];
        let fr = new FileReader();
        fr.onload = () => {
            geom2map(fr.result);
        };
        fr.readAsText(f);
    }
    function preventDefaults(e)
    {
        e.preventDefault();
        e.stopPropagation();
    }

    // file
    document.getElementById('inputfile')
        .addEventListener('change', function ()
        {
            var fr = new FileReader();
            fr.onload = function ()
            {
                geom2map(fr.result);
            };

            fr.readAsText(this.files[0]);
        });

    window.ca = undefined;
    window.ctx = undefined;
    window.onload = function ()
    {
        ca = document.getElementById("ca");
        ctx = ca.getContext("2d");
    };


    // todo drag drop

    function geom2map(t)
    {
        console.time("benchmark");

        ctx.clearRect(0, 0, ca.width, ca.height);

        console.log("length of the file:", t.length);
        let total_walls = 0;
        const substitution = {
            ',': ' '
        };
        const accuracy = document.getElementById("accuracy_holder").value;
        window.geom_map = {
            shops: [],
            walls: [],
            map_name: document.getElementById("input_map_name").value,
        };

        // find shops
        // process circles
        let s = t;
        // let shops = [];
        window.max_elem_x = -Infinity;
        window.max_elem_y = -Infinity;
        while (s.includes("<circle "))
        {
            let c_ind = s.indexOf("<circle ");
            let sx = "", sy = "", sid = "";
            let sdname = ""; // data-name

            for (let i = c_ind + 8; i < s.length - 10; i++)
            {
                if (s.substr(i, 3) === 'cx=') // cx="..."
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        sx += s[j];
                    }
                }
                else if (s.substr(i, 3) === 'cy=')
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        sy += s[j];
                    }
                    break;
                }
                else if (s.substr(i, 3) === 'id=')
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        sid += s[j];
                    }
                }
                else if (s.substr(i, 10) === 'data-name=')
                {
                    for (let j = i + 11; j < s.length && s[j] !== '\"'; j++)
                    {
                        sdname += s[j];
                    }
                }
            }

            let shop_name = (sdname === "" ? sid : sdname);
            if (shop_name !== "")
            {
                console.log('shop x y shop_name', sx, sy, shop_name);
                window.geom_map.shops.push({name: shop_name, tag: `${sx},${sy}`, x: sx, y: sy});
                max_elem_x = Math.max(max_elem_x, sx);
                max_elem_y = Math.max(max_elem_y, sy);

                const sz = 5;
                ctx.beginPath();
                ctx.fillRect(sx - sz / 2, sy - sz / 2, sz, sz);
                ctx.fillText(shop_name, parseFloat(sx), parseFloat(sy));
                ctx.stroke();
            }

            s = s.substr(0, c_ind) + s.substr(c_ind + 1);
            console.log('line to remove:', s[c_ind]);
        }


        // find walls
        // process paths
        s = t;
        while (s.includes(" d="))
        {
            total_walls++;

            let d = s.indexOf(" d=");
            d += 4;
            let path = s[d];
            for (let i = d + 1; i < s.length && s[i] !== '\"'; i++)
            {
                path += (substitution[s[i]] === undefined ? s[i] : substitution[s[i]]);
            }

            console.log('path', path);

            console.log('starting drawing it out...');
            document.getElementById("src2").setAttribute("d", path);
            decompose_svg(src2, accuracy);

            s = s.substr(0, d - 4 + 1) + s.substr(d - 4 + 1 + 1);
            console.log('to remove:', s[d - 4]);
        }
        // process lines
        s = t;
        while (s.includes("<line "))
        {
            total_walls++;

            let l = s.indexOf("<line ");
            let x1 = "", y1 = "", x2 = "", y2 = "";
            for (let i = l + 6; i < s.length - 1; i++)
            {
                if (s.substr(i, 2) === 'x1') // x1="..."
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        x1 += s[j];
                    }
                }
                else if (s.substr(i, 2) === 'y1')
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        y1 += s[j];
                    }
                }
                else if (s.substr(i, 2) === 'x2')
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        x2 += s[j];
                    }
                }
                else if (s.substr(i, 2) === 'y2')
                {
                    for (let j = i + 4; j < s.length && s[j] !== '\"'; j++)
                    {
                        y2 += s[j];
                    }
                    break;
                }
            }

            window.geom_map.walls.push({x1, y1, x2, y2});

            console.log('line', x1, y1, x2, y2);
            console.log('draw line');
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            s = s.substr(0, l) + s.substr(l + 1);
            console.log('line to remove:', s[l]);
        }


        // adding grid
        let GRID_ACCURACY = parseFloat(document.getElementById("grid_accuracy_holder").value); // dx, dy  grid step
        const GRID_DENSITY = 5;
        for (let y = 0; y <= max_elem_y + GRID_ACCURACY * 5; y += GRID_ACCURACY)
        {
            for (let x = 0; x <= max_elem_x + GRID_ACCURACY * 5; x += GRID_ACCURACY)
            {
                for (let t = 0; t < GRID_DENSITY; t++)
                {
                    // ghost shop - grid node
                    let sh_c = {
                        shop_name: "",
                        sx: x + Math.random() * GRID_ACCURACY,
                        sy: y + Math.random() * GRID_ACCURACY,
                    };
                    window.geom_map.shops.push({
                        name: sh_c.shop_name,
                        tag: `${sh_c.sx},${sh_c.sy}`,
                        x: sh_c.sx,
                        y: sh_c.sy
                    });
                    const sz = 1;
                    ctx.beginPath();
                    ctx.fillRect(sh_c.sx - sz / 2, sh_c.sy - sz / 2, sz, sz);
                    ctx.fillText(sh_c.shop_name, parseFloat(sh_c.sx), parseFloat(sh_c.sy));
                    ctx.stroke();
                }
            }
        }

        console.log('total walls:', total_walls);

        pedir_map2graph(window.geom_map);
    }


    function choose_shop(randomly)
    {
        if (randomly === true || randomly === undefined)
        {
            let rand_ind = Math.floor(Math.random() * window.geom_map.shops.length) % window.geom_map.shops.length;
            let found = false;

            for (let t = 0; t < 1e5; t++)
            {
                if (window.geom_map.shops[rand_ind].name === '')
                {
                    rand_ind = Math.floor(Math.random() * window.geom_map.shops.length) % window.geom_map.shops.length;
                    found = true;
                }
                else
                {
                    break;
                }
            }

            if (found)
            {
                ctx.beginPath();
                const sz = 10;
                ctx.fillStyle = '#ff3000';
                // ctx.fillStyle = '#5bc5ff';
                ctx.fillRect(window.geom_map.shops[rand_ind].x - sz / 2,
                    window.geom_map.shops[rand_ind].y - sz / 2,
                    sz, sz);
                ctx.stroke();

                return window.geom_map.shops[rand_ind];
            }
            else
            {
                // alert('cannot choose shop!');
                console.log('%cCannot choose shop!', 'background: orange');
            }
        }
    }


    function valid_token(token)
    {
        return token !== '' &&
            token !== undefined &&
            token !== "undefined" &&
            token !== null &&
            // token.length === 64 &&
            token.substr(0, 3) === 'tok';
    }

    function pedir_map2graph()
    {
        if (window.geom_map.map_name === '')
        {
            alert('map name not set');
            location.reload();
            return;
        }

        // delete localStorage['token']; // debug

        let token;
        if (localStorage['token'] === undefined)
        {
            token = prompt("Enter access token:");
            console.log('%ctoken: ' + token, 'background: green; color: black;');
            if (!valid_token(token))
            {
                alert('invalid token');
                delete localStorage['token'];
                location.reload();
                return;
            }
            else
            {
                localStorage['token'] = token;
            }
        }
        else
        {
            token = localStorage['token'];
            if (!valid_token(token))
            {
                alert('invalid token');
                delete localStorage['token'];
                location.reload();
                return;
            }
        }

        console.time("map2graph time");
        console.log('starting pidiendo map2graph');
        console.log('estimated time:', ((window.geom_map.shops.length + window.geom_map.walls.length) / 5707) * (199780), 'ms');
        console.log(`map elements: ${window.geom_map.shops.length} + ${window.geom_map.walls.length} = ${window.geom_map.shops.length + window.geom_map.walls.length}`);

        $.ajax({
            type: 'POST',
            url: '/map2graph',
            data: JSON.stringify({
                map: window.geom_map,
                access_token: token,
            }),
            dataType: 'json',
            contentType: "application/json",
        }).done(response =>
        {
            console.timeEnd("map2graph time");

            console.log('%cShops: ' + JSON.stringify(response.shops), 'background: blue;');
            console.log('%cGraph: ' + JSON.stringify(response.graph), 'background: cyan; color: black;');

            // document.getElementById("output_java_code").textContent = JSON.stringify(response.graph);
            // document.getElementById("output_shops_code").textContent = JSON.stringify(response.shops);
            window.response_graph = JSON.stringify(response.graph);
            window.response_shops = JSON.stringify(response.shops);
            download_json(response.shops, `${window.geom_map.map_name}_n2t.json`);
            download_json(response.graph, `${window.geom_map.map_name}_map.json`);

            // const job_count = 20;
            // for (let i = 0; i < job_count; i++)
            // {
            // from_shop = choose_shop();
            // to_shop = choose_shop();
            // pedir_path(response.graph, from_shop.name, to_shop.name, true);
            // }
        });
    }


    function download_json(o, file_name)
    {
        var a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        var json = JSON.stringify(o),
            blob = new Blob([json], {type: "octet/stream"}),
            url = window.URL.createObjectURL(blob);
        a.href = url;
        a.download = file_name;
        a.click();
        window.URL.revokeObjectURL(url);
        a.remove();
    }


    function draw_full_graph(graph)
    {
        if (graph === undefined) // not specified
        {
            if (window.response_graph)
            {
                graph = JSON.parse(window.response_graph);
            }
            else
            {
                return;
            }
        }

        console.log('draw this graph:', graph);

        for (f in graph)
        {
            let es = graph[f];

            // console.log({es});

            for (let i = 0; i < es.length; i++)
            {
                let p1 = f.split(',').map(x => parseFloat(x));
                let p2 = es[i].t.split(',').map(x => parseFloat(x));

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.stroke();
            }

        }
    }

    function draw_brief_graph(graph, shops) // only edges each v->u from shopset
    {
        if (graph === undefined) // not specified
        {
            if (window.response_graph)
            {
                graph = JSON.parse(window.response_graph);
                shops = JSON.parse(window.response_shops);
            }
            else
            {
                return;
            }
        }

        console.log('draw this graph:', graph);
        console.log('using these shops:', shops);

        for (ind in shops)
        {
            let f = shops[ind][1];
            let es = graph[f];

            for (let i = 0; i < es.length; i++)
            {
                let p1 = f.split(',').map(x => parseFloat(x));
                let p2 = es[i].t.split(',').map(x => parseFloat(x));

                ctx.beginPath();
                ctx.moveTo(p1[0], p1[1]);
                ctx.lineTo(p2[0], p2[1]);
                ctx.stroke();
            }

        }
    }

    function draw_cada_ruta(map_name, shops, floor) // only edges each v->u from shopset
    {
        if (shops === undefined)
        {
            shops = JSON.parse(window.response_shops);
        }

        console.log(`%cDraw cada ruta: ${shops}`, 'background-color: red');
        console.log('Routes in total:', shops.length ** 2);

        if (floor === undefined)
        {
            floor = prompt('floor #');
        }

        for (i in shops)
        {
            for (j in shops)
            {
                let s = shops[i][1];
                let t = shops[j][1];

                // console.log(`%sPath ${s} > ${t}`, 'background-color: yellow; color: black;')

                pedir_path(undefined, s, t, false, floor, floor);

                // for (let i = 0; i < es.length; i++)
                // {
                //     let p1 = f.split(',').map(x => parseFloat(x));
                //     let p2 = es[i].t.split(',').map(x => parseFloat(x));
                //
                //     ctx.beginPath();
                //     ctx.moveTo(p1[0], p1[1]);
                //     ctx.lineTo(p2[0], p2[1]);
                //     ctx.stroke();
                // }
            }
        }
    }


    const CLIENT_TOKEN = "tokeeFahngeisaela1raraup4Eu1Eitahghahkahf4AeCh3yuen2Ge9ahtoaneewchiekah6Eije0jee3quaey9omu7ahch2Ka7aey5poh3Geiphai3Nea9eiM9Ieyoi8thu2vaichagheo8thohCof4koo4aeRooghaiGhiVahShaengahDaiyohlseithaezaeteiThoo1awahr8ohMei5xe5evaezai3ma2gaemaireen5aKae4pkae2ePh2Quai4mahsuiP3gootie1epaevaiT5ooweichai1kie5iepohyasiewuangoongahphiechisup6ainaiheeH8kaeb9ee0eifahSheikeiDiegahcuwdie3eephaebahgu3aekaux8eeb5oDu5yaica0ahvi0fo7faeNg5aiRohwephuCeegh0ohlee4bahk3phi7uaciegh5Raejeithaa5ooghohzae8thu0IwoLeehaez4yaipaeSh3fierie1eete4fuseotoofoothoh4peiQuujoh7asahXaew8udievaKu4yohdeo0aeQueey8zi7Eem0eiMahl2fohroRooziedei1iejahph0evu5uophahthiphaepoh5vohR2BeZai9vooFoo9chaazohwooNgia6moh7chipoophiewohfah0zun9queepo0eirish8Nahs9chohc3theiWeeghaco7yoh6roohph9heyahphee2JaifeiphuzieTou1Iowee0Ii6choo9eethahf4Nee3itiathieph3aeshaipuo6yei4bee6hai3ey2OLahChe6eishahVaXi4aesa5ainekeigh3Shoh5auNeegamoh3phaChii3phaeTaiNuSheituzengah0peighaino3vue1eer5eihae6UtaeChaochoh9no0iquei7upoo8wieShai5aeshe3Xee4naphohcohz9uu4shahng3eR7rish1tazi1oob9Beichauvoozeeyowael6pah1lthah6oothohz3OoK1euru8ouJ3Vichohpheijai2loumiepahph3ReipohkecEeshiethue8che2ook7aeJoPhohchoht5oorulohkoom4thoh8Seeweiceu2tOicath5coothaiwaixae1Aigeed6IuPu6queesahkumieth6ahb5aeyeoh5ae";

    function pedir_path(graph, start, target, provide_geocoding, start_floor, target_floor)
    {
        console.log('starting pidiendo the path');
        console.log(`from ${start} to ${target}`);
        console.log('current graph state:', graph);
        // console.time("pedir_path time");

        if (start === undefined)
        {
            start = prompt("enter start shop name");
        }
        if (target === undefined)
        {
            target = prompt("enter target shop name");
        }
        if (start_floor === undefined)
        {
            start_floor = prompt("enter start floor");
        }
        if (target_floor === undefined)
        {
            target_floor = prompt("enter target floor");
        }

        $.ajax({
            type: 'POST',
            url: '/path_ab',
            data: JSON.stringify({
                // graph: JSON.stringify(graph),
                start,
                target,
                provide_geocoding,
                // map_name: window.geom_map.map_name,
                mname_start: document.getElementById("input_map_name").value + ":" + start_floor,
                mname_target: document.getElementById("input_map_name").value + ":" + target_floor,
                access_token: CLIENT_TOKEN,
            }),
            dataType: 'json',
            contentType: "application/json",
        }).done(response =>
        {
            // console.timeEnd("pedir_path time");
            console.log('pedir_path done => response:', response);

            if (response.target_reachable === false)
            {
                console.log(`%cCannot get from ${start} to ${target}`, 'background: red');
                return;
            }

            let path = response.bp.map(c => c.split(',').map(x => parseFloat(x)));
            console.log('transform path (bp)', path);
            draw_path(path);
        });
    }


    function draw_path(p)
    {
        ctx.beginPath();
        // stroke styling
        var gradient = ctx.createLinearGradient(0, 0, 170, 0);
        gradient.addColorStop("0", "magenta");
        gradient.addColorStop("0.5", "blue");
        gradient.addColorStop("1.0", "red");
        ctx.lineCap = 'round';
        ctx.lineWidth = 2;
        ctx.strokeStyle = gradient;
        //stroke styling
        ctx.moveTo(p[0][0], p[0][1]);
        for (let i = 1; i < p.length; i++)
        {
            ctx.lineTo(p[i][0], p[i][1]);
        }
        ctx.stroke();

        console.timeEnd("benchmark");
        console.log(`map elements: ${window.geom_map.shops.length} + ${window.geom_map.walls.length} = ${window.geom_map.shops.length + window.geom_map.walls.length}`);
    }


    function decompose_svg(path, num)
    {
        var l = path.getTotalLength();
        var p = path.getPointAtLength(0);
        var d = `M${p.x} ${p.y}`;
        var pp;
        ctx.beginPath();
        // ctx.moveTo(p.x, p.y);
        for (var i = (l / num); i <= l; i += (l / num))
        {
            p = path.getPointAtLength(i);
            d += `L${p.x} ${p.y}`;
            ctx.lineTo(p.x, p.y);
            // window.java_code_output += (pp !== undefined ? `new Wall(${pp.x}*1., ${pp.y}*1., ${p.x}*1., ${p.y}*1.), ` : "");
            if (pp !== undefined)
            {
                window.geom_map.walls.push({x1: pp.x, y1: pp.y, x2: p.x, y2: p.y});
                window.max_elem_x = Math.max(max_elem_x, p.x);
                window.max_elem_y = Math.max(max_elem_y, p.y);
            }
            pp = p;
        }
        ctx.stroke();
        path.setAttribute("d", d + "z")
    }
</script>


<textarea id="output_java_code"
          style="width: 60%;
          height: 5%;
          opacity: 20%;
          position: fixed;
          left: 4px;
          bottom: 5%;
          visibility: hidden;
          resize: none;"
          placeholder="jsoned graph will pop up in here"></textarea>
<textarea id="output_shops_code"
          style="width: 35%;
          height: 5%;
          opacity: 20%;
          position: fixed;
          right: 4px;
          bottom: 5%;
          visibility: hidden;
          resize: none;"
          placeholder="shops info"></textarea>
<input id="input_map_name" placeholder="map name" style="position: fixed; right: 0;"/>
<button style="position: fixed; right: 0;" onclick="pedir_path(undefined, undefined, undefined, true)">-></button>
<br/>
<canvas id="ca" width="3000" height="3000" style="border: 1px dashed rgba(110,110,110,0.1);"></canvas>
<br/>

<svg style="visibility: hidden" width="1" height="1" viewBox="0 0 1 1" fill="none" stroke="black" stroke-width="5">
    <path id="src2" d="M100 10 A90 90 0 0 0 100 190A90 90 0 0 0 100 10z"/>
</svg>


</body>
</html>

